\documentclass[uplatex,dvipdfmx]{jsarticle}
\usepackage{listings,jvlisting}
\usepackage{color}
\usepackage{xr}

\lstset{
  backgroundcolor=\color[rgb]{0.9,0.9,0.9},
  frame=single,
  basicstyle=\ttfamily
}
\makeatletter
\newcommand*{\addFileDependency}[1]{% argument=file name and extension
  \typeout{(#1)}
  \@addtofilelist{#1}
  \IfFileExists{#1}{}{\typeout{No file #1.}}
}
\makeatother

\newcommand*{\myexternaldocument}[1]{%
    \externaldocument{#1}%
    \addFileDependency{#1.tex}%
    \addFileDependency{#1.aux}%
}
\myexternaldocument{../categoryTheoryIntro/CategoryTheoryIntro}

\newcommand{\pr}[1]{\colorbox[rgb]{0.9,0.9,0.9}{\lstinline{#1}}}
\newcommand{\functype}[2]{\pr{#1 -> #2}}
\newcommand{\refcti}[1]{[CTI]\ref{#1}}
\newcommand{\fpmor}[3]{\pr{#1 :: #2 -> #3}}
\input{../categoryTheoryIntro/preemble.tex}
\begin{document}
  \title{関数型言語と圏論の関係性}
  \author{https://otamusan.github.io/FPandCategory/categoricalfp.pdf}
  \maketitle
	\tableofcontents
  \pagebreak
  \section{Haskellとデザインパターン}
  オブジェクト指向言語におけるデザインパターンとは、プログラムの一部を再利用、テストを容易にするための設計手法である。これらは継承やら実装やらのオブジェクト指向言語特有の操作によって抽象化されていて、さらにそれらの操作で閉じている。

  関数型プログラミング、特にHaskellではリストの操作や入出力などの副作用を伴う操作を、抽象的で汎用性があり極力関数型言語の操作で構成される設計によって与えている。これらは言うなればデザインパターンによって言語機能の拡張しているとみなすことができ、こういった設計もここではデザインパターンと呼ぶことにする。

  \subsection{関数型}
  Haskellにも一般のプログラミングと同じようにデータ型が存在し、整数値を持つ\pr{Int}型や\pr{True}と\pr{False}を持つ\pr{Bool}型などがある。
  また整数値を受け取って二倍にして返す、つまり$double(x)=2x$なる
  関数\pr{double}は\pr{Int}から\pr{Int}への関数であり、haskellではこのように記述する。
  \begin{lstlisting}
    double :: Int -> Int
    double x = 2*x
    -- >>> double 4
    -- 8
  \end{lstlisting}
  ある型\pr{a}からある型\pr{b}への関数は、関数の型\functype{a}{b}に含まれる。すなわち、関数そのものも値とみなすということである。それによって、関数型から関数型への関数なども定義できるようになる。その一例を示そう。

  関数\fpmor{f}{Int}{Int}を、自身を合成した関数\fpmor{f.f}{Int}{Int}へと写す関数
  
  \fpmor{mul}{(Int -> Int)}{(Int -> Int)}は次のように記述する。
  \begin{lstlisting}
    mul :: (Int -> Int) -> (Int -> Int)
    mul f = f.f
    -- >>> (mul double) (5)
    -- 20
  \end{lstlisting}
  後に説明するが、\pr{.}という記号は前後の関数を合成する操作であり、\pr{f.f}は$f\circ f$を意味する。すなわちこの計算は
  \[(mul(double))(5)=(double \circ double)(5)=double(double(5))=20\]のように行われる。このような関数を引数、戻り値にするような関数を高階関数と呼ぶ。
  
  二つの整数を足し合わせる操作は$add(x,y)=x+y$のように定義できる。この関数は引数を二つ持つ多変数関数であり、これはHaskellでは
  \begin{lstlisting}
    add :: Int -> Int -> Int
    add x y = x + y
    -- >>> add 5 6
    -- 11
  \end{lstlisting}
  のように型を与えて定義することができる。関数の型\pr{Int -> Int -> Int}は左から二つは引数の型で、一番右が返り値の型となっている。
  なぜこのような表記をするかというと、\pr{Int -> Int -> Int}は\pr{Int -> (Int -> Int)}の省略であり、$add(x,y)$を$(add(x))(y)$とみなしているためである。ゆえに\fpmor{add(x)}{Int}{Int}は引数に\pr{x}を足し合わせる関数となっている。またこのように想定された数より少ない引数を適用することを部分適用と呼ぶ。
  \subsection{多相型と多相関数}
  関数型\functype{a}{b}は単一の型ではなく、任意の型\pr{a},\pr{b}に対して個別に定義できるのであった。このように既存の型から生成できる型を多相型という。また、多相型から多相型への型を考えることもできる。例えば高階関数と多変数関数を用いれば、関数を合成する操作に次のような型を与えることができる。
  \begin{lstlisting}
    apply :: (Int -> Int) -> Int -> Int
    apply f x = f(x)
    -- >>> apply double 10
    -- 20
  \end{lstlisting}
  しかし、引数の関数は\pr{Int}か\pr{Int}への関数に制限されているが、実際は関数がどのような型であっても、適用の操作は行えるはずである。
  そこで、\pr{apply}関数の引数の型を\pr{a}、返り値の型を\pr{b}に置き換える。
    \begin{lstlisting}
    apply :: (a -> b) -> a -> b
    apply f x = f(x)
    -- >>> apply double 10
    -- 20
    -- >>> apply not False
    -- True
  \end{lstlisting}
  例のために真理値を反転する関数\fpmor{not}{Bool}{Bool}を使用している。
  
  このように関数の引数の型を任意の型\pr{a},\pr{b}に置き換えることで、様々な型の値に対応した関数を定義することができ、このような関数を多相関数と呼ぶ。

  このような多相関数は基本的に既存の多相関数の組み合わせによって定義される。この例であれば、\pr{apply}の定義に用いた\pr{f(x)}はすでにhaskell側によって多相関数\pr{(\$) :: (a -> b) -> a -> b}としてすでに定義されているため、定義することができた。

  値の適用が関数として与えられているように、関数の合成も関数で行うことができる。つまり関数\pr{double}の定義に用いた\pr{.}が関数であり、
  \begin{center}
    \pr{(.)\ ::\ (b -> c) -> (a -> b) -> a -> c}
  \end{center}
  という型が与えられているということである。

  このように関数型プログラミングでの処理の記述は変数の仲介を除けば、関数に関数を合成する操作や、関数に値を適用する操作によって行われる。
  \subsection{基本的なデータ型}
  任意の型\pr{a},\pr{b}に対して多相型である直積型\pr{(a,b)}は以下の関数で構成される。
  \begin{lstlisting}
    (,) :: a -> b -> (a, b)
    fst :: (a, b) -> a
    snd :: (a, b) -> b

    -- >>> (,) 4 5
    -- (4,5)
    -- >>> fst (4,5)
    -- 4
    -- >>> snd (4,5)
    -- 5
  \end{lstlisting}
  実行例を見て分かるように、\pr{(a,b)}の値はある型\pr{a}と\pr{b}の値をそれぞれ持つ。
  また、型\pr{a},\pr{b}の値\pr{x},\pr{y}に対して、\[\pr{fst (x, y)}=\pr{x},\ \pr{snd (x, y)}=\pr{y}\]が成り立つ。

  直積型は二つの型の値を持つが、ゼロ個の型の値を持つ型も存在する。この型をUnit型\pr{()}といい、ただ一つの値\pr{()}を持つ。

  任意の型\pr{a},\pr{b}に対して多相型である直和型\pr{Either a b}は以下の関数で構成される。
  \begin{lstlisting}
    Right :: b -> Either a b
    Left :: a -> Either a b
    either :: (a -> c) -> (b -> c) -> Either a b -> c

    isZero :: Int -> Bool
    isZero x = x==0

    -- >>> either isZero not (Left 0)
    -- True
    -- >>> either isZero not (Right True)
    -- False
  \end{lstlisting}
  \pr{isZero}関数の\pr{x==0}は両辺が等しいか真理値を返す関数\pr{(==)\ ::\ Int\ ->\ Int\ ->\ Bool}であり、定義から分かるように\pr{Either a b}は\pr{a}か\pr{b}の値のどちらか一方を持つ。

  \pr{either}関数についてこの例では、\functype{Int}{Bool}と\functype{Bool}{Bool}を受け取っているため、次の引数の型は\pr{Either\ Int\ Bool}を受け取る。もし\pr{Either\ Int\ Bool}の値が\pr{Int}であれば、\functype{Int}{Bool}型の\pr{isZero}関数に適用し、\pr{Bool}であれば\functype{Bool}{Bool}型の\pr{not}関数に適用する、という関数である。

  また任意の型\pr{x}とその値\pr{y}、
  \begin{lstlisting}
    f :: a -> x
    g :: b -> x
  \end{lstlisting}に対して、
  \begin{align*}
    \pr{either f g (Left x)}&=\pr{f x}\\
    \pr{either f g (Right x)}&=\pr{g x}
  \end{align*}
  が成り立つ。

  一般に直和を用いて新しい型を定義する場合、\pr{Either}型を用いて定義するのではなく、haskellにおける多相型を定義する構文によって行われることが多い。また\pr{either}関数もパターンマッチと呼ばれる構文によって行われる。

  \begin{lstlisting}
    data EitherIB = Value Int | Judge Bool
    calc :: EitherIB -> Bool
    calc (Value a) = isZero a
    calc (Judge a) = not a
    -- >>> :t Value
    -- Value :: Int -> EitherIB
    -- >>> :t Judge
    -- Judge :: Bool -> EitherIB
  \end{lstlisting}
  この例では、\pr{EitherIB}が\pr{Either Int Bool}に該当し、\pr{Value}が\pr{Left}、\pr{Judge}が\pr{Right}に対応する。
  \subsection{デザインパターンの例}
  最後にこれらを応用したMaybe型を見る。
  \begin{lstlisting}
    data Maybe a  =  Nothing | Just a
  \end{lstlisting}
  \pr{Maybe a}は\pr{Either}型を用いると、\pr{Either () a}と書ける。ここでの\pr{Nothing}は\pr{Unit}型の値を与える関数とみなせるが、値はただ一つであるため単に定数と見て良い。すなわち\pr{Maybe a}はただ一つの値\pr{Nothing}と型\pr{a}の値のどちらかの値を持つ型である。

  この\pr{Maybe}の想定している用途として、以下の例を扱う。
  \begin{lstlisting}
    div10 :: Float -> Float
    div10 = (10 /)
    -- >>> div10 4
    -- 2.5
    -- >>> div10 0
    -- Infinity
  \end{lstlisting}
  \pr{div10}は10を与えられた数で割る関数であるが、結果のように零除算についてはInfinityという値が与えられる。これを素直に計算の失敗と見なし、型によって計算結果が正しく出力されないことを示したい。そこで、
  \begin{lstlisting}
    div10' :: Float -> Maybe Float
    div10' x = if x == 0 then Nothing else Just $ div10 x

    -- >>> div10' 4
    -- Just 2.5
    -- >>> div10' 0
    -- Nothing
  \end{lstlisting}
  という関数を定義する。これは零除算が発生する場合\pr{Nothing}を返し、そうでない場合は\pr{Just}によって計算結果を\pr{Maybe}に包んで返している。

  これによって、\pr{Maybe Float}の値を用いて計算を行うときは、必ず\pr{Nothing}と\pr{Just}の場合分けが必要になり、他の言語でいうNullチェックが必要なことを型レベルで示していることになる。

  またここではこれ以上語らないが、\pr{Maybe}型の挙動はモナドと呼ばれるデザインパターンによって一般化される。これによって特に\pr{a -> Maybe b}型の関数と\pr{b -> Maybe c}型の関数の自然な合成を与えることができる。
  \section{圏論}
  関数型言語では関数という言葉が使われるように、型を属する値の集合、関数を値の集合から値の集合への写像とみなすことができる。集合を写像の視点から観察する場合、圏論によって一般化することが有効である場合が多い。そのため以降は型と関数の議論を圏論によってモデル化することを考える。
  \subsection{型と関数の圏}
  型を対象、関数を射とする圏$\cat{H}$を定義する。
  圏の定義の詳細は\refcti{def-category}を参照
  Haskellには二つの関数が等しいことを判定する一般的な操作は無い。そのため関数の等号を改めて定義する。
  \begin{define}[関数の外延性]\label{def-function-extensionality}
    関数\fpmor{f}{a}{b}、\fpmor{g}{a}{b}と型\pr{a}の任意の値\pr{x}において\[\pr{f x}=\pr{g x} \iff \pr{f} = \pr{g}\]
  \end{define}
  \begin{define}[型と関数の圏]\label{def-hask-category}
		\begin{quote}~
			\begin{mydescription}
        \item[対象] すべての型の集合を対象集合$\obj{H}$とする。また各型を対象とみなす場合$A,B,C\cdots$と表記し、型とみなす場合は\pr{a},\pr{b},\pr{c}$\cdots$とする。また各型の値を圏論の文脈では$a,b,c\cdots$と表記することにする。
        \item[射] 対象$A$から対象$B$への射集合$\arset{H}{A}{B}$を集合と見なした関数型\functype{a}{b}とする。また各射は$f,g,h\cdots$と表記する。
        \item[射の合成] 射の合成を行う写像$\mor{\circ}{\arset{H}{B}{C}\times\arset{H}{A}{B}}{\arset{H}{A}{C}}$を任意の射$\mor{f}{A}{B},\ \mor{g}{B}{C}$に対して\pr{f.g}によって定義する。
        \item[恒等射の存在] 任意の型\pr{a}に対して恒等関数\fpmor{id}{a}{a}は、\pr{id x = x}と定義できる。この恒等関数を恒等射とし、$\mor{id_A}{A}{A}$と表記する。
        \item[結合律] 関数の外延性より、集合の圏における結合律と同様の手法で証明できる。\refcti{def-category-of-sets}を参照
        \item[単位元律]結合律と同様に\refcti{def-category-of-sets}を参照
		  \end{mydescription}
		\end{quote}
	\end{define}
  次に型の直積と直和の普遍性との関係を見る。
  \begin{prop}[$\cat{H}$の積]\label{prop-h-has-product}
    圏$\cat{H}$は積を持つ
  \end{prop}
  \begin{proof}
    $(\pr{(a,\ b)},\pr{fst},\pr{snd})$は型\pr{a},\pr{b}における積であることを示せば良い。
    任意の型\pr{x}、任意の関数
    \begin{lstlisting}
      f :: x -> a
      g :: x -> b
    \end{lstlisting}に対して、
    \begin{lstlisting}
      h :: x -> (a, b)
      h x = (f x, g x)
    \end{lstlisting}とする。
    すると明らかに
    \begin{align*}
      \pr{fst . h \$ x}&=\pr{f x}\\
      \pr{snd . h \$ x}&=\pr{g x}
    \end{align*}
    であり、\ref{def-function-extensionality}の関数の外延性より
    \begin{align*}
      \pr{fst . h}&=\pr{f}\\
      \pr{snd . h}&=\pr{g}
    \end{align*}
    が成り立ち、\pr{h}は\pr{f}、\pr{g}の射の対であることが分かる。
    またある関数\pr{i\ ::\ x\ ->\ (a,\ b)}によって与えられた値\pr{i\ x\ ::\ (a,\ b)}が
    \begin{align*}
      \pr{fst (i x)} &= \pr{f x}\\
      \pr{snd (i x)} &= \pr{g x}
    \end{align*}
    を満たす時、\pr{fst},\pr{snd}の性質から\pr{i\ x\ =\ (f\ x,\ g\ x)}が成り立つ。よって\ref{def-function-extensionality}の関数の外延性より\pr{i} = \pr{h}である。これにより射の対\pr{h}の一意に存在することを示せた。 よって$(\pr{(a,\ b)},\pr{fst},\pr{snd})$は積であり、任意の型\pr{a},\pr{b}に対して存在するから$\cat{H}$は積を持つ。
  \end{proof}
  \begin{prop}[$\cat{H}$の終対象]\label{prop-h-has-terminal}
    圏$\cat{H}$は終対象を持つ。
  \end{prop}
  \begin{proof}
    ある型\pr{x}において
    \begin{lstlisting}
      f :: x -> ()
      f x = ()
    \end{lstlisting}
    なる写像を考える。またこのような関数は任意の\pr{x}について考えることができる。
    \begin{lstlisting}
      g :: x -> ()
      g x = ()
    \end{lstlisting}
    なる写像を考えると、\pr{f x}=\pr{()}=\pr{g x}が成り立ち、\ref{def-function-extensionality}の関数の外延性より\pr{f}=\pr{g}が成り立つ。\pr{f :: x -> ()}なる関数が一意に存在するから\pr{()}は$\cat{H}$における終対象であり、$\cat{H}$は終対象を持つ。
  \end{proof}
  \begin{define}[余積の定義]\label{def-coproduct}
    ある対象$A,B$に対して$(A+B,\ \iota_A,\ \iota_B)$が余積であるとは、
    $\mor{\iota_A}{A}{A+B},\ \mor{\iota_B}{B}{A+B}$であり、任意の対象$X$と任意の射$\mor{f}{A}{X},\ \mor{g}{B}{X}$に対して
    \[[f,g]\circ\iota_A = f,\ [f,g]\circ\iota_B = g\]であるような$\mor{[f,g]}{A+B}{X}$が一意に存在するときである。
  \end{define}
  \begin{prop}[$\cat{H}$の余積]\label{prop-h-has-coproduct}
    圏$\cat{H}$は余積を持つ、すなわち任意の対象$A,B$に対して余積$A+B$が存在する。
  \end{prop}
  \begin{proof}
    厳密に証明するのであれば自然同型\[\arset{H}{A+B}{-}\cong\arset{H}{A}{-}\times \arset{H}{B}{-}\]を示すべきであるが、ここでは少し妥協して\pr{Either a b}の値が\pr{Left},\pr{Right}のみによって与えられるとする。


    積と同様に(\pr{Either a b},\ \pr{Left},\ \pr{Right})が型\pr{a}、\pr{b}における余積であることを示せば良い。任意の型\pr{x}、任意の関数
    \begin{lstlisting}
      f :: a -> x
      g :: b -> x
    \end{lstlisting}
    に対して、
    \begin{align*}
      \pr{(either f g) Left x} &= \pr{f x}\\
      \pr{(either f g) Right x} &= \pr{g x}
    \end{align*}
    が成り立つのであった。よって、
    \begin{align*}
      \pr{(either f g).Left} &= \pr{f}\\
      \pr{(either f g).Right} &= \pr{g}
    \end{align*}
    であり、
    \begin{align*}
      \pr{h.Left} &= \pr{f}\\
      \pr{h.Right} &= \pr{g}
    \end{align*}
    を満たすような\pr{h :: Either a b -> x}が存在するとする。
    すると、\pr{a}の任意の値\pr{x}と\pr{b}の任意の値\pr{y}に対して、
    \begin{align*}
      \pr{(either f g).Left x} &= \pr{h.Left x}\\
      \pr{(either f g).Right y} &= \pr{h.Right y}
    \end{align*}
    が成り立つ。\pr{Either a b}の値が\pr{Left},\pr{Right}のみによって与えられるから、\ref{def-function-extensionality}の関数の外延性より\pr{either f g} = \pr{h}であり、条件を満たす\pr{either f g}が一意に定まることが分かった。

    よって(\pr{Either a b},\ \pr{Left},\ \pr{Right})は\pr{a}、\pr{b}に対する余積であり、これが任意の型に対して存在するから$\cat{H}$は余積を持つ
  \end{proof}
  \subsection{関手と自然変換}
  Haskellには他のオブジェクト指向言語におけるインターフェイスのような概念がある。これを型クラスといい、それを実装したものはインスタンスと呼ぶ。例えばある型\pr{a}がシリアル化可能、つまり型\pr{a}の値と文字列の相互変換が可能であるには\pr{a -> String}と\pr{String -> a}なるような二つの関数を持っていなければならない。ただし文字列を値とする型を\pr{String}とする。そこでその条件を型クラス\pr{Serializable}として記述する。
  \begin{lstlisting}
  class Serializable a where
    serialize :: a -> String
    deserialize :: String -> a
  \end{lstlisting}
  真理値は単に\pr{True}\pr{False}を文字列と見なしたり、真理値と見なしたりできシリアル化可能であると述べることができる。そこで以下に示すように型\pr{Bool}を型クラス\pr{Serializable}のインスタンスにする。
  \begin{lstlisting}
  instance Serializable Bool where
    serialize :: Bool -> String
    serialize x = if x then "True" else "False"
    deserialize :: String -> Bool
    deserialize x = x == "True"
  \end{lstlisting}
  ここで注意すべきことは本来シリアル化であればStringから値が完全に復元できるように
  \[\pr{serialize.deserialize x} = \pr{x} ,\ \pr{deserialize.serialize x} = \pr{x}\]が成り立つように\pr{serialize}と\pr{deserialize}を定義するべきであるが、一般的に等式によってそのような制約を設けることはできない。そのため型クラスにそのような等式が存在する場合は、手動でそれを満たすかどうか調べなければならない。

  また多相型は既存の型を新しい型に写す写像の印象が強く、一般の型とは大きく異なるような概念に見える。しかし関数の全体を型とみなすのと同様に、多相型もまた型の一種である。よって単に多相型によって写された型\pr{f a}だけでなく、多相型\pr{f}もインスタンス化が可能である。その例として\pr{Functor}型を示そう。
  \begin{lstlisting}
    class Functor f where
      fmap :: (a -> b) -> f a -> f b
  \end{lstlisting}
  \pr{fmap}の型に\pr{f a}が含まれるため、\pr{f}は多相型であることが要請されることが分かる。また、関数\pr{fmap}はファンクタ則と呼ばれる以下の等式を満たさなければならない。
  \begin{align*}
    &\pr{fmap id} = \pr{id}\\
    &\pr{fmap (f . g)} = \pr{fmap f . fmap g}
  \end{align*}
  この\pr{Functor}という型クラスは、多相型が既存の型を新しい型へ写すような操作と見なした場合、型だけでなくその周りの関数も同様に写すことができることを要請する。

  またファンクタ則については、新しい関数に写した場合、ある程度元の関数を引き継ぐよう要請するものである。

  多相型と一般の型の関係が分かりにくいため、型の型であるカインドを紹介する。型を更に上位の型であるカインドによって分類するわけだが、一般の型に比べて複雑ではない。例えば多相型でない具体的な型\pr{Int}、\pr{Bool}のカインドは\pr{*}である。多相型\pr{Maybe}は\pr{* -> *}であり、\pr{*}の具体的な型を\pr{*}の具体的な型に写す関数と見なしている。

  \pr{(a,b)}や\pr{a -> b}は二つの任意の型から一つの型を与えていたが、これも多変数関数と同様に\pr{(,) :: * -> * -> *}というようなカインドが与えられている。

  \begin{lstlisting}
    -- >>> :k Int
    -- Int :: *
    -- >>> :k Bool
    -- Bool :: *
    -- >>> :k Maybe
    -- Maybe :: * -> *
    -- >>> :k (,)
    -- (,) :: * -> * -> *
    -- >>> :k (->)
    -- (->) :: * -> * -> *
  \end{lstlisting}

  さてFunctorの話に戻ると、この名前の通りこれは圏$\cat{H}$における自己関手にあたる。関手の定義は\refcti{def-functor}を参照。
  \begin{prop}\label{prop-functor-is-self-functor}
    多相型\pr{f}が\pr{Functor}のインスタンスである時、\pr{f}は$\cat{H}$における自己関手である。
    \begin{quote}
			\begin{mydescription}
		\item[対象関数] \pr{a}を\pr{f a}に写す操作を対象関数とする。
		\item[射関数] \pr{fmap :: (a -> b) -> f a -> f b}を射関数とする。\\
    \pr{fmap :: (a -> b) -> (f a -> f b)}とみなすことができるため、\ref{def-hask-category}の圏$\cat{H}$の射集合の定義より、$\arset{H}{A}{B}=\pr{a -> b}$であったから、\pr{fmap}は射関数とすることができる。
		\item[恒等射の保存] 正しくファンクタ則の\pr{fmap id} = \pr{id}が恒等射の保存である。
		\item[射の合成の保存] 正しくファンクタ則の\pr{fmap (f . g)} = \pr{fmap f . fmap g}が射の合成の保存である。
		\end{mydescription}
		\end{quote}
  \end{prop}
  これから\pr{Functor}のインスタンスを紹介していくが、ファンクタ則を満たすかどうかはここでは証明しない。興味があれば\refcti{chap-6-functor}章を読んでほしい。

  対象$B$を対象$A\times B$に写す操作は関手$\functor{A \times -}{H}{H}$であったから、同様に\pr{(,) a :: * -> *}となる多相型も\pr{Functor}のインスタンス化ができる。この\pr{(,) a}という型は、多相型\pr{(,)}を多変数関数と見なしたときに、型\pr{a}を部分適用して得られた多相型である。
  \begin{lstlisting}
    instance Functor ((,) a) where
      fmap f (x,y) = (x, f y)
  \end{lstlisting}
  \pr{Functor}の求める型のカインドは\pr{* -> *}であるが、これを\pr{* -> * -> *}に拡張した\pr{Bifunctor}が存在する。
  \begin{lstlisting}
    class Bifunctor p where
      bimap :: (a -> b) -> (c -> d) -> p a c -> p b d
      bimap f g = first f . second g

      first :: (a -> b) -> p a c -> p b c
      first f = bimap f id
      second :: (b -> c) -> p a b -> p a c
      second = bimap id
  \end{lstlisting}
  \pr{Bifunctor}型クラスでは必要とされる関数にすでに実装がされていて、\pr{first}、\pr{second}は\pr{bimap}を参照、\pr{bimap}は\pr{first}、\pr{second}を参照している。
  これはどちらか一方を実装すれば、もう片方も自動的に定義されるということである。詳細は述べないが、\pr{second}が\pr{Functor}型クラスの実装である\pr{fmap}に該当し、\pr{first}が\pr{Functor}で実装しきれなかった方の関手性である。これは正しく圏論における双関手であり、詳しくは\refcti{def-bifunctor}を参照してほしい。
  
  直積型である\pr{(a, b)}と直和型である\pr{Either a b}も\pr{Bifunctor}のインスタンスであり、
  \begin{lstlisting}
    instance Bifunctor (,) where
      bimap f g ~(a, b) = (f a, g b)
    instance Bifunctor Either where
      bimap f _ (Left a) = Left (f a)
      bimap _ g (Right b) = Right (g b)
  \end{lstlisting}
  のように実装されている。直感的には\pr{(a, b)}型と\pr{Either a b}型の\pr{a}と\pr{b}の値にそれぞれ関数を適用しているという点で、一種の値の並列計算のように思える。

  また、直積と直和が関手的であることから、それらで構成される\pr{Maybe}型も\pr{Functor}の実装を自然に与えることができる。実際デフォルトの実装は
  \begin{lstlisting}
    instance Functor Maybe where
      fmap _ Nothing       = Nothing
      fmap f (Just a)      = Just (f a)
  \end{lstlisting}
  であるが、\pr{Either}型によって定義された\pr{Maybe}型の場合は
  \begin{lstlisting}
    instance Functor (Either () a) where
      fmap f = bimap id f
  \end{lstlisting}
  のように\pr{Either}型の双関手性を用いて定義できる。\pr{Maybe}型による\pr{fmap}の用途としては、値\pr{m :: Maybe a}に対して関数\pr{f :: a -> b}を適用できるという点にあるだろう。
  
  すなわち\pr{(fmap f) m :: Maybe b}である。\pr{fmap}の定義にある通り、\pr{m}が\pr{Nothing}である時何も行わず、\pr{Just n}であった時\pr{f}に\pr{n}を適用するという操作を行うが、\pr{fmap}によって面倒な場合分けを自動で行われる点が便利である。
  
  さらに最初に多相型の例として挙げた関数型もまた\pr{Functor}型のインスタンスである。内容としては\refcti{def-covariant-hom-functor}と同じであるが、
  \begin{lstlisting}
    instance Functor ((->) r) where
      fmap = (.)
  \end{lstlisting}
  と簡潔に定義される

  \pr{fmap}の型は\pr{(a -> b) -> f a -> f b}であったから、
  この場合は\pr{(a -> b) -> (r -> a) -> (r -> b)}となる。よって型は合致している。これを関手の観点から見ると、ある関数\pr{f :: a -> b}を用いて部分適用を行うと\pr{(.) f :: (r -> a) -> (r -> b)}が得られるが、これは与えられた関数に\pr{f}を合成する関数である。

  \pr{(->)}も\pr{(,)}と同様に\pr{* -> * -> *}なるカインドを持つから、\pr{Bifunctor}のインスタンスと考えるかもしれないがそうはならない。特に\pr{first :: (a -> b) -> p a c -> p b c}に該当する関数が存在しないためである。これに\pr{(->)}を当てはめると、\pr{second :: (a -> b) -> (a -> c) -> (b -> c)}となるが、\pr{a -> b}と\pr{a -> c}の関数に対する一般的な合成は特に定義されていない。しかし\pr{Bifunctor}の代わりに\pr{(->)}は\pr{Profunctor}と呼ばれる型クラスのインスタンスである。

  次に自然変換について説明する。Haskellにおいて自然変換は単なる多相関数によって表される。すなわち、\pr{Functor}型クラスのインスタンスである多相型二つの間の多相関数であり、自然性と呼ばれる等式を満たすならば自然変換である。

  この自然性というのは、\pr{Functor}である\pr{f},\pr{g}とその間の多相関数\pr{n :: f x -> g x}と関数\pr{g :: a -> b}に対して、
  \[\pr{fmap g.n}=\pr{n.fmap g}\]が成り立つことである。
  自然変換についても詳細は\refcti{def-natural-transfomation}を参照

  またHaskellでは型\pr{a}を同じ型\pr{a}に写すような多相型は構成できないが、これが存在すると見なし\pr{fmap}関数に恒等関数を割り当てることで\pr{Functor}型クラスのインスタンスとみなす。

  また、\refcti{def-evaluation-arrow}、\refcti{def-coevaluation-arrow}の評価射、余評価射の定義に従って、関数\pr{ev}、\pr{ce}を定義する
  \begin{lstlisting}
    ev :: (b -> a, b) -> a
    ev p = fst p $ snd p
    ce :: a -> (b -> (a, b))
    ce = (,)
  \end{lstlisting}
  これも\refcti{naturality-of-eval}、\refcti{prop-naturality-of-coeval}より、型\pr{a}に対して自然になる。

  また自然変換は命題\refcti{prop-university-of-nat}のような普遍性を持ち、それは定義\refcti{def-end}のエンドと呼ばれる対象に一般化されるのであった。
  これをHaskellで記述すると
  \begin{lstlisting}
    {-# LANGUAGE RankNTypes #-}
    data End p = End {prj :: forall a. p a a}
    -- >>> :t End
    -- End :: (forall a. p a a) -> End p
    -- >>> :t prj
    -- prj :: End p -> p a a
  \end{lstlisting}
  このように定義できる。ただし、ファンクタ則や自然性と同じようにエンドの持つ普遍性は記述できない。またこの定義では\pr{p a b}が共変関手、反変関手として振る舞うことを記述できていないが、これは\pr{p a b}が前に述べた\pr{Profunctor}型クラスのインスタンスであるように制約を持たせれば良い。
  また自然変換の全体はエンドであったから、\pr{p a a}=\pr{f a -> g a}=\pr{(Mor f g) a a}としてエンドによって定義することができる。
  \begin{lstlisting}
    type Nat f g = End (Mor f g)

    data Mor f g a b = Mor{mor :: f a -> g b}

    toMaybe :: Either b a -> Maybe a
    toMaybe = either (const Nothing) Just

    toMaybeNat :: End (Mor (Either b) Maybe)
    toMaybeNat = End (Mor toMaybe)

    -- >>> :t mor (prj toMaybeNat)
    -- mor (prj toMaybeNat) :: Either b1 b2 -> Maybe b2
  \end{lstlisting}
  この例では多相関数\pr{toMaybe}をエンド\pr{toMaybeNat}に変換している。また\[\pr{mor.prj :: End (Mor f g) -> f b -> g b}\]によって元の多相関数へと復元することもできる。
  \subsection{関数型とべき随伴}
  \begin{define}[随伴関手]\label{def-adjoint-functor}
      ある二つの関手$\functor{L}{C}{D}$、$\functor{R}{D}{C}$が随伴関手であるとは、以下の性質を満たす時である。
      \begin{quote}
        \begin{mydescription}
          \item[単位と余単位]ある自然変換$\nat{\eta}{Id_\cat{C}}{R\circ L}$と$\nat{\epsilon}{L\circ R}{Id_\cat{D}}$が存在する。また$\eta$を単位、$\epsilon$を余単位と呼ぶことにする。
          \item[三角恒等式]
          自然変換の二等式
          \[(\epsilon\circ L)\cdot(L\circ \eta)=ID_L\]
          \begin{center}
            \begin{tikzpicture}[auto]
              \node (L1) at (0, 0) {$L$};
              \node (L2) at (2, -2) {$L$};
              \node (LRL) at (2, 0) {$LRL$};
              \draw[double,double equal sign distance,-implies] (L1) -- node[swap] {$ID_L$} (L2);
              \draw[double,double equal sign distance,-implies] (L1) -- node {$L\circ \eta$} (LRL);
              \draw[double,double equal sign distance,-implies] (LRL) -- node {$\epsilon\circ L$} (L2);
            \end{tikzpicture}
          \end{center}
          \[(R\circ \epsilon)\cdot (\eta\circ R)=ID_R\]
          \begin{center}
            \begin{tikzpicture}[auto]
              \node (L1) at (0, 0) {$R$};
              \node (L2) at (2, -2) {$R$};
              \node (LRL) at (2, 0) {$RLR$};
    
              \draw[double,double equal sign distance,-implies] (L1) -- node[swap] {$ID_R$} (L2);
              \draw[double,double equal sign distance,-implies] (L1) -- node {$\eta\circ R$} (LRL);
              \draw[double,double equal sign distance,-implies] (LRL) -- node {$L\circ \epsilon$} (L2);
            \end{tikzpicture}
          \end{center}
          が成り立つ。
        \end{mydescription}
      \end{quote}
      また$\functor{L}{C}{D}$が左随伴関手、$\functor{R}{D}{C}$が対応する右随伴関手である時、$L\dashv R$と表記する
  \end{define}
  \begin{prop}[べき随伴]\label{prop-h-has-exp-adjoint}
    \pr{(, b)}\ $\dashv $\ \pr{(->) b}である。

    ただし、\pr{(, b)}は\pr{Functor}型クラスのインスタンスではないが\pr{Bifunctor}型クラスの\pr{first}関数を\pr{fmap}関数とすることで\pr{Functor}のインスタンスとみなす。
  \end{prop}
  \begin{proof}
    単位を多相関数\pr{ce}、余単位を\pr{ev}とする。これらの多相関数や多相型が関手、自然変換であることは確認したから三角恒等式を満たすことを調べれば良い。
    １つ目の等式は\[\pr{ev.(first ce)}=\pr{id}\]と表される。しかし添字が省略されてわかりにくいため、各々の関数の型を示しておく。
    \begin{lstlisting}
      ce :: a -> (b -> (a, b))
      fst ce :: (a, b) -> ((b -> (a, b)), b)
      ev.(first ce) :: (a, b) -> (a, b)
    \end{lstlisting}
    これに\pr{(a, b)}型の任意の値\pr{(x, y)}を適用すると、
    \begin{align*}
      \pr{(ev.(first ce))(x, y)}&=\pr{ev(first ce (x,y))}\\
      &=\pr{ev((,) x, y)}\\
      &=\pr{(,) x y}\\
      &=\pr{(x, y)}
    \end{align*}
    となり、$\pr{ev.(first ce)}=\pr{id}$が成り立つ。
    同様に２つ目の等式は\[\pr{(fmap ev).ce}=\pr{id}\]である。各関数の型は以下のようになっていて、
    \begin{lstlisting}
      ev :: (b -> a, b) -> a
      fmap ev :: (b -> (b -> a, b)) -> (b -> a)
      (fmap ev).ce :: (b -> a) -> (b -> a)
    \end{lstlisting}
    \pr{(b -> a)}型の任意の値$f$を適用すると、
    \begin{align*}
      \pr{((fmap ev).ce)f} &= \pr{(fmap ev)(ce f)}\\
      &=\pr{(fmap ev)((,) f)}\\
      &=\pr{ev.((,) f)}\\
    \end{align*}
    ここで型\pr{b}の任意の値\pr{y}に対して、\\
    \begin{align*}
      \pr{(ev.((,) f)) y} &= \pr{ev(f, y)}\\
      &= \pr{f(y)}\\
    \end{align*}
    であるから、\pr{ev.((,) f)}=\pr{f}である。よって$\pr{(fmap ev).ce}=\pr{id}$となる。
  \end{proof}
  \begin{define}[カルテジアン閉圏]\label{def-ccc}
    圏$\cat{C}$がカルテジアン閉圏(ccc)であるとは、積と終対象を持ち、積関手$\functor{(-\times B)}{C}{C}$に対して右随伴となるような関手$\functor{(-)^{B}}{C}{C}$を持つということである。
  \end{define}
  \begin{prop}\label{prop-h-is-ccc}
    圏$\cat{H}$はcccである。
  \end{prop}
  \begin{proof}
    命題\ref{prop-h-has-product}、\ref{prop-h-has-terminal}、
    \ref{prop-h-has-exp-adjoint}より、圏$\cat{H}$はcccである。
  \end{proof}
  
  \section{Optics}
  \subsection{LensとPrism}
  Opticsの例としてLens、Prismを挙げる。

  Lensはオブジェクト指向におけるフィールドと、それに対するセッター、ゲッターを一般化した概念である。例えばある型$S$が型$A$を内部に保持する時、$A$に関する操作としては二つの関数$\mor{set}{S\times A}{S}$、$\mor{get}{S}{A}$が考えられる。
  直感的には$set$は$S$の値$s$と$A$の値$a$を受け取って、$s$の内部の$A$の値を$a$に置き換えた、新しい$S$の値を返す関数である。また$get$は$S$の値$s$の内部の$A$の値を返す関数である。
  
  例として\pr{Person}型の値が型の直積によって\pr{String}型の値を持つとする。この\pr{Person}の値の中の文字列を$set$、$get$を用いて記述する
  \begin{lstlisting}
    type Person = (String, Int)

    set :: (Person, String) -> Person
    set (p, s) = (s, snd p)
    get :: Person -> String
    get = fst

    person :: Person
    person = ("A",20)
    -- >>> get person
    -- "A"
    -- >>> set (person, "B")
    -- ("B",20)
  \end{lstlisting}
  ここでは直積型を用いて$S$の値が$A$の値を持つことを明示的に示したが、一般の場合ではそうは行かない。そのため$set,\ get$関数による等式で間接的に示す。
  \[\mor{\pi_A = get\circ set}{S\times A}{A}\]
  \[\mor{id_S = set\circ\tuple{id_S,get}}{S}{S\times A}\]
  \[\mor{set\circ(set\times id_A) = put\circ(\pi_S\circ\pi_{S\times A}\times \pi_A)}{(S\times A)\times A}{S}\]
  １つ目の等式は値をその中の$A$の値によって$set$で置き換えても$S$の値は変わらないことを示す。
  ２つ目は$set$によって与えた$a$の値が、$get$によって取り出せることを示し、
  ３つ目はある$s$に$a$を置き換えた時、その前の$a$が上書きされることを示している。

  次にLensの一種の双対であるPrismを紹介する。これは部分型としての包含関係を表す概念であり、二つの関数$\mor{review}{A}{S}$、$\mor{match}{S}{S+A}$で構成される。この場合$A$から$S$への値にアップキャストする操作は$review$関数により容易に行えて、$S$から$A$への値のダウンキャストは可能であれば$A$の値、不可能であればそのまま$S$の値を返す操作とみなせる。例えば、整数の内の奇数のみを持つ型\pr{Odd}を考え、\pr{Integer}型との包含関係を$review$、$match$で記述する
  \begin{lstlisting}   
    newtype Odd = Odd{toInt :: Integer} deriving Show
    match :: Integer -> Either Integer Odd
    match x = if odd x 
      then Right (Odd x)
      else Left x
    review :: Odd -> Integer
    review = toInt

    -- >>> match 4
    -- Left 4
    -- >>> match 3
    -- Right (Odd {toInt = 3})
    -- >>> review (Odd 5)
    -- 5
  \end{lstlisting}
  Lensと同様にPrismでも、包含関係を間接的に示すのに$review,\ match$関数を用いた等式で示す。また等式における$[id_S,review]$は積における射の対の双対である。
  \[match\circ review = \iota_A\mor{}{A}{S+A}\]
  \[[id_S,review]\circ match = id_S\mor{}{S}{S}\]
  １つ目の等式は$A$の値$a$をアップキャストをしてからダウンキャストを行うと、$S+A$における$A$の方の値が必ず得られて、それが$a$を$S+A$に入射したものと一致することを示している。
  ２つ目の等式は$S$の値$s$が$match$によってダウンキャストが成功した場合、更にアップキャストを行なった値は$s$と一致し、ダウンキャストが失敗した場合も$s$と一致することを示している。
  
  ここでLensの$\mor{set}{S\times A}{S}$と$\mor{get}{S}{A}$の組の全体を$Lens(S,A)$、Prismの$\mor{review}{A}{S}$と$\mor{match}{S}{S+A}$の組の全体を$Prism(S,A)$と表記することにしよう。これはHaskellにおいてはそのような多相型を定義することである。
  \begin{lstlisting}
    data Lens s a = Lens{get :: s -> a , set :: (s, a) -> s}
    data Prism s a = Prism{review :: a -> s , match :: s -> Either s a}
    -- >>> :t Lens
    -- Lens :: (s -> a) -> ((s, a) -> s) -> Lens s a
    -- >>> :t Prism
    -- Prism :: (a -> s) -> (s -> Either s a) -> Prism s a
  \end{lstlisting}

  また$Lens(S,A)$における$get$関数を$get_{S,A}$と表記する。また$set$関数やPrismにおいても同様に表記する。
  
  これによってLensの合成$\mor{\circ}{Lens(S,A)\times Lens(T,S)}{Lens(T,A)}$が定義を行う。
  \begin{define}
    \[\mor{\circ}{Lens(S,A)\times Lens(T,S)}{Lens(T,A)}\]なる関数$\circ$を
    任意の$\mor{set_{T,S}}{T\times S}{T}, \mor{get_{T,S}}{T}{S},\ \mor{set_{S,A}}{S\times A}{S},\ \mor{get_{S,A}}{S}{A}$に対して
    \begin{align*}
      get_{T,A}&=get_{S,A}\circ get_{T,S}\\
      set_{T,A}&=set_{T,S}\circ(id_T\times set)\circ a_{TSA}\circ(\tuple{id_T, get_{T,S}}\times id_A)
    \end{align*}
    と定義する。
    \begin{center}
      \begin{tikzpicture}[auto]
        \node (TA) at (0, 0) {$T\times A$};
        \node (TSpA) at (4, 0) {$(T\times S)\times A$};
        \node (TpSA) at (8, 0) {$T\times (S\times A)$};
        \node (TS) at (12, 0) {$T\times S$};
        \node (T) at (14, 0) {$T$};

				\draw[->] (TA) to node{\scriptsize$\tuple{id_T,get_{T,S}}\times id_A$}(TSpA);
        \draw[->] (TSpA) to node{$a_{TSA}$}(TpSA);
        \draw[->] (TpSA) to node{$id_T\times set_{S,A}$}(TS);
        \draw[->] (TS) to node{$set_{T,S}$}(T);

      \end{tikzpicture}
    \end{center}
  \end{define}
  $set_{T,A}$の定義が複雑かもしれないが、単に$T$から$S$を取り出し、$S$に$A$を与えてその$S$をまた$T$に戻しているだけである。

  またLensの合成において恒等射のような働きをするLensも定義できる。
  \begin{define}[恒等Lens]
    \begin{align*}
      get_{S,S} &= id_S\\
      set_{S,S} &= \pi_{L,S\times S}
    \end{align*}
  \end{define}
  PrismにおいてもLensと同様に合成が定義できる。
  \subsection{Opticsへの一般化}
  Opticsを構成するための圏論の概念としてコエンドを定義する。
  \begin{define}[コエンド]
    ある圏$\cat{C,D}$と、関手$\functor{F}{C^{op}\times C}{D}$に対するコエンド$(\coend{C}{C} F(C,C),\kappa)$を以下のように構成する。
    \begin{quote}
      \begin{mydescription}
        \item[余楔] 余楔と呼ばれる組$(Y,\mu)$を、圏$\cat{D}$のある対象$Y$と、
        圏$\cat{C}$の任意の対象$X$に対して$\mor{\mu_C}{Y}{F(X,X)}$なる射が存在し、圏$\cat{C}$の任意の射$\mor{f}{B}{A}$に対して$\mu_A\circ F(A,f)=\mu_B\circ F(f,B)$が成り立つような$\mu$によって構成する。
        \begin{center}
          \begin{tikzpicture}[auto]
            \node (FG) at (0, 0) {Y};
            \node (FAGA) at (3, 0) {$F(A,A)$};
            \node (FBGB) at (0, -2) {$F(B,B)$};
            \node (FAGB) at (3, -2) {$F(A,B)$};
    
            \draw[<-] (FG) to node{$\mu_A$}(FAGA);  
            \draw[<-] (FG) to node{$\mu_B$}(FBGB);
            \draw[<-] (FAGA) to node{$F(A,f)$}(FAGB);
            \draw[<-] (FBGB) to node{$F(f,B)$}(FAGB);
          \end{tikzpicture}
        \end{center}
        \item[普遍性] ある余楔$(\coend{C}{C}F(C,C),\kappa)$が$F$に対してコエンドであるとは、余楔$(Y,\mu)$が存在して、任意の対象$X$において$\mu=h\circ \kappa_X$が成り立つような$\mor{h}{\coend{C}{C} F(C,C)}{Y}$が一意に存在する時である。
        また、$\kappa$を余積の場合と紛らわしくない場合は入射と呼ぶことにする。
        \begin{center}
          \begin{tikzpicture}[auto]
            \node (FG) at (0, 0) {$\coend{C}{C} F(C,C)$};
            \node (X) at (-1.5, 1) {$Y$};
            \node (FAGA) at (3, 0) {$F(A,A)$};
            \node (FBGB) at (0, -2) {$F(B,B)$};
            \node (FAGB) at (3, -2) {$F(A,B)$};
    
            \draw[<-] (FG) to node{$\kappa_A$}(FAGA);
            \draw[<-] (X) to node{$h$}(FG);
    
            \draw[<-] (FG) to node{$\kappa_B$}(FBGB);
            \draw[<-,bend left = 20] (X) to node{$\mu_A$}(FAGA);
            \draw[<-,bend right = 20] (X) to node[swap]{$\mu_B$}(FBGB);
            \draw[<-] (FAGA) to node{$F(A,f)$}(FAGB);
            \draw[<-] (FBGB) to node{$F(f,B)$}(FAGB);
          \end{tikzpicture}
        \end{center}
      \end{mydescription}
    \end{quote}
  \end{define}
  コエンドの普遍性は$\coend{C}{C} F(C,C)$が圏$C$の任意の対象に対する$F(C,C)$の余積であることを示していて、$F(A,B)$の元に対し$f$を$A$と$B$のどちらに適用しても入射によって示されるということである。
  
  余積という部分をもう少し詳しく見ると、$F(A,A)$から$Y$への射の族$\mu$は同様の射の族$\kappa$によって単なる射$h$へと分解される。同様に$\kappa$が他の単なる射によって分解されるかといえば、コエンドの普遍性からそのような射の族は$\kappa$以外には存在しないと言える。そういった意味で$(\coend{C}{C} F(C,C),\kappa)$は余楔の中で、射の族としての最小限の性質のみを持っていると考えられる。

  コエンドもHaskellで定義できる
  \begin{lstlisting}
    {-# LANGUAGE ExistentialQuantification #-}
    data Coend p = forall a. Coend (p a a)
    -- >>> :t Coend
    -- Coend :: p a a -> Coend p
  \end{lstlisting}
  \pr{Coend}の値コンストラクタを見ると、\pr{p a a}から\pr{Coend p}へ写る過程で型引数\pr{a}の情報を忘れてしまっている。そのため一度\pr{Coend}に写してしまうと、元の型に復元することはできなくなり、一般的には一切の操作が行えなくなってしまう。そういった意味でこれは任意の型\pr{a}で添字付けられた\pr{p a a}の直和であるように思える。

  コエンドに限らずこういった定義の手法を存在量化と呼ぶが、実用の面では最低限操作が行えることを保証するために\pr{a}の型に制約を加えることが多い。

  次にコエンドとエンドの関係性についての重要な命題を示す。
  \begin{prop}
    \[\arset{Set}{\coend{C}{C} T(C,C)}{X}\cong\cend{C}{C}\arset{Set}{T(C,C)}{X}\]であり、$X,T$に対して自然。
  \end{prop}
  \begin{proof}
    反変Hom関手は余連続であるから余極限を保つ。またエンドは極限によって定義できるように、コエンドも余極限によって定義できる。これによってコエンドは反変Hom関手によって保たれるが、反変性よりコエンドの双対であるエンドとして保たれる。
  \end{proof}
  \begin{define}[Optics]
    対称モノイダル圏$\cat{C}$における組$(S,S')$、$(A,A')$の間のOpticを
    \[Optic_\cat{C}(S,S',A,A')=\coend{C}{M}\arset{C}{S}{M\otimes A}\times \arset{C}{M\otimes A'}{S'}\]と定義する。
  \end{define}
  この定義におけるコエンドの普遍性は、$\arset{C}{S}{M\otimes A}\times \arset{C}{M\otimes A'}{S'}$の元$\tuple{l,r}$に対し、
  \[\kappa_N((f\otimes A)\circ l, r)=\kappa_M(l, r(f\otimes A'))\]が成り立つような$\kappa$を入射とする$\arset{C}{S}{M\otimes A}\times \arset{C}{M\otimes A'}{S'}$の余積である。
  次にOpticsがLens、Prismの一般化であることを示したいが、そのために余米田の補題が必要であるためここで示す。

  \begin{define}[余米田の補題]
    任意の圏$\cat{C}$と対象$A$と関手$\functor{F}{C}{Set}$において
    \[FA\cong\coend{C}{C} FC\times\arset{C}{C}{A}\]
    またここでの積分記号はエンドではなくコエンドである。
  \end{define}
  \begin{proof}
    米田の原理より、\[A\cong B\iff\arset{C}{A}{-}\cong\arset{C}{B}{-}\]であるから、$\arset{Set}{FA}{X}\cong\arset{Set}{\coend{C}{C} FC\times\arset{C}{C}{A}}{X}$が$X$に対して自然に成り立つことを示せば良い。またコエンドは関手であるから、同型を保つ。
    \begin{align*}
      \arset{Set}{\coend{C}{C} FC\times\arset{C}{C}{A}}{X}&\cong\cend{C}{C}\arset{Set}{FC\times\arset{C}{C}{A}}{X}&\text{(反変Hom関手の余極限の保存)}\\
      &\cong\cend{C}{C}\arset{Set}{\arset{C}{C}{A}\times FC}{X}&\text{(積の交換)}\\
      &\cong\cend{C}{C}\arset{Set}{\arset{C}{C}{A}}{\arset{Set}{FC}{X}}&\text{(べき随伴の射集合同型)}\\
      &\cong\arset{Set}{FA}{X}&\text{(反変米田の補題)}
    \end{align*}
    よってである。計算のために使用した同型はすべて$X,F,A$に対して自然であるから、$FA\cong\coend{C}{C} FC\times\arset{C}{C}{A}$が成り立ち、$F,A$に対して自然である。
  \end{proof}
  また同様の方法で$F$に反変関手を取る場合も証明できる。
  すなわち、任意の関手$\functor{F}{C^{op}}{Set}$と対象$A$に対して
  \[FA\cong\coend{C}{C}FC\times \arset{C}{A}{C}\]が成り立つ。

  余米田の補題によれば、$FA$が$FC\times\arset{C}{C}{A}$を与える関手のコエンドとなるということであるが、具体的な入射の構成は不明である。余楔を用いた証明も思いつくが、$\cat{H}$が余積を持つことの証明のようにコエンドの元を列挙できないため、この方法では難しい。そのため厳密な証明では無いが、
  \begin{proof}
    $(FA,\omega)$がコエンドであるとは、任意の余楔$(X,\mu)$に対して$h\circ\omega_B = \mu_B$なる射$h$が一意に存在するときである。$Fb$の任意の元$b$と$\mor{g}{B}{A}$に対して\[\omega_B(b, f) = Ff(b)\]と定義する。すると任意の射$\mor{g}{C}{A}$と$Fb$の任意の元$b$に対し\[\omega_B(b,g\circ f)=F(g\circ f)(b)=Fg(Ff(b))=\omega_C(Ff(b),g)\]が成り立つから、$(FA,\omega)$は確かに余楔である。
    \begin{center}
      \begin{tikzpicture}[auto]
        \node (FG) at (0, 0) {$FA$};
        \node (X) at (-2.5, 1) {$X$};
        \node (FAGA) at (5, 0) {$FB\times\arset{Set}{B}{A}$};
        \node (FBGB) at (0, -2) {$FC\times\arset{Set}{C}{A}$};
        \node (FAGB) at (5, -2) {$FB\times\arset{Set}{C}{A}$};
    
        \draw[<-] (FG) to node{$\omega_B$}(FAGA);
        \draw[<-] (X) to node{$h$}(FG);
    
        \draw[<-] (FG) to node{$\omega_C$}(FBGB);
        \draw[<-,bend left = 20] (X) to node{$\mu_A$}(FAGA);
        \draw[<-,bend right = 20] (X) to node[swap]{$\mu_B$}(FBGB);
        \draw[<-] (FAGA) to node{$id_{FC}\times \arset{Set}{f}{A}$}(FAGB);
        \draw[<-] (FBGB) to node{$Ff\times id_{\arset{Set}{C}{A}}$}(FAGB);
      \end{tikzpicture}
    \end{center}

    ここで\[h = \mu_A(-,id_A)\]とすると、任意の$B$とその元$b$、射$\mor{f}{B}{A}$に対して
    \begin{align*}
      \mu_A(-,id_A)\circ\omega_B(b,f) &= \mu_A(Ffb,id_A)\\
      &=\mu_B(b,f)&\text{(余楔の定義)}
    \end{align*}
    であるから、$\mu_A(-,id_A)\circ\omega_B = \mu_B$であることが分かった。
    \begin{center}
      \begin{tikzpicture}[auto]
        \node (FG) at (0, 0) {$FA$};
        \node (X) at (-2.5, 1) {$X$};
        \node (FAGA) at (5, 0) {$FB\times\arset{Set}{B}{A}$};
        \node (FBGB) at (0, -2) {$FA\times\arset{Set}{A}{A}$};
        \node (FAGB) at (5, -2) {$FB\times\arset{Set}{A}{A}$};
    
        \draw[<-] (FG) to node{$\omega_B$}(FAGA);
        \draw[<-] (X) to node{$\mu_A(-,id_A)$}(FG);
    
        \draw[<-] (FG) to node{$\omega_A$}(FBGB);
        \draw[<-,bend left = 20] (X) to node{$\mu_B$}(FAGA);
        \draw[<-,bend right = 20] (X) to node[swap]{$\mu_A$}(FBGB);
        \draw[<-] (FAGA) to node{$id_{FB}\times \arset{Set}{f}{A}$}(FAGB);
        \draw[<-] (FBGB) to node{$Ff\times id_{\arset{Set}{A}{A}}$}(FAGB);
      \end{tikzpicture}
    \end{center}
    次にこのような$\mu_A(-,id_A)$の一意性を調べれば良い。$h'\circ\omega_B = \mu_B$となるような$h'$が存在するとする。すると、任意の$B$とその元$b$、射$\mor{f}{B}{A}$に対して
    \begin{align*}
      h'\circ\omega_B(b,f) &=\mu_B(b,f)\\
      &=\mu_A(Ffb,id_A)\\
      &=\mu_A(-,id_A)(Ffb)\\
      &=\mu_A(-,id_A)\circ \omega_B(b,f)\\
    \end{align*}
    よって
  \end{proof}


  \begin{prop}
    $Optic(S,S',A,A')_{\cat{C},\times}$をOpticの定義のテンソル積を積に置き換えたものとする。すると、
    \[Optic(S,S,A,A)_{\cat{C},\times} = Lens(S,A)\]である。
  \end{prop}
  \begin{proof}
    \begin{align*}
      \coend{C}{M}\arset{C}{S}{M\times A}\times \arset{C}{M\times A}{S}&\cong\coend{C}{M}\arset{C}{S}{M}\times \arset{C}{S}{A}\times \arset{C}{M\otimes A}{S}&\text{(共変Hom関手の積の保存)}\\
      &\cong\arset{C}{S}{A}\times \arset{C}{S\times A}{S}&\text{(余米田の補題)}\\
    \end{align*}
  \end{proof}
  同様にPrismもOpticで表せる。
  \begin{prop}
    \[Optic(S,S,A,A)_{\cat{C},+} = Prism(S,A)\]である。
  \end{prop}
  \begin{proof}
    \begin{align*}
      \coend{C}{M}\arset{C}{S}{M+A}\times \arset{C}{M+A}{S}&\cong\coend{C}{M}\arset{C}{S}{M+A}\times \arset{C}{M}{S}\times \arset{C}{A}{S}&\text{(反変Hom関手の余積の保存)}\\
      &\cong\arset{C}{S}{S+A}\times \arset{C}{A}{S}&\text{(余米田の補題)}\\
    \end{align*}
  \end{proof}
\end{document}
・TaPL
・私が書いた圏論入門
・すごいH本
・https://hackage.haskell.org/
・basic concept of enriched category theory

https://www.cs.ox.ac.uk/jeremy.gibbons/publications/proyo.pdf
https://hackage.haskell.org/package/optics-0.4.2/docs
https://arxiv.org/pdf/2001.07488.pdf
https://arxiv.org/pdf/1809.00738.pdf
https://arxiv.org/pdf/1501.02503.pdf　(coend calculus)
https://bartoszmilewski.com/2017/03/29/ends-and-coends/
タイトル　圏論側からの方向性　圏論の概念
現在だとデザイン
総合報告まとめ

int型はint値の集合
